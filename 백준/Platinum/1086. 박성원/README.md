# [Platinum V] 박성원 - 1086 

[문제 링크](https://www.acmicpc.net/problem/1086) 

### 성능 요약

메모리: 27880 KB, 시간: 144 ms

### 분류

비트마스킹, 다이나믹 프로그래밍, 비트필드를 이용한 다이나믹 프로그래밍

### 제출 일자

2026년 2월 19일 14:09:13

### 문제 설명

<p>박성원은 이 문제를 풀지 못했다.</p>

<p>서로 다른 정수로 이루어진 집합이 있다. 이 집합의 순열을 합치면 큰 정수 하나를 만들 수 있다. 예를 들어, {5221,40,1,58,9}로 5221401589를 만들 수 있다. 합친수가 정수 K로 나누어 떨어지는 순열을 구하는 프로그램을 작성하시오.</p>

<p>하지만, 박성원은 이 문제를 풀지 못했다.</p>

<p>따라서 박성원은 그냥 랜덤하게 순열 하나를 정답이라고 출력하려고 한다. 이 문제에는 정답이 여러 개 있을 수도 있고, 박성원이 우연히 문제의 정답을 맞출 수도 있다.</p>

<p>박성원이 우연히 정답을 맞출 확률을 분수로 출력하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 집합의 수의 개수 N이 주어진다. N은 15보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 집합에 포함된 수가 주어진다. 각 수의 길이는 길어야 50인 자연수이다. 마지막 줄에는 K가 주어진다. K는 100보다 작거나 같은 자연수이다.</p>

### 출력 

 <p>첫째 줄에 정답을 기약분수 형태로 출력한다. p/q꼴로 출력하며, p는 분자, q는 분모이다. 정답이 0인 경우는 0/1로, 1인 경우는 1/1로 출력한다.</p>

## AI 코드 리뷰

<template>

### 코드 리뷰
이 코드는 주어진 자연수 집합의 다양한 순열을 생성하여 이들의 합친 수가 정수 K로 나누어 떨어질 확률을 계산하는 프로그램입니다. 전체 코드는 기능적으로 세 부분으로 나눌 수 있습니다.

```cpp
unsigned long long factorial(){
    unsigned long long res = 1;
    for(int i=2; i<=N; i++){
        res *= i;
    }
    return res;
}
```
**설명 1**: 이 함수는 N! (N 팩토리얼)을 계산하여 반환합니다. 이는 가능한 순열의 총 개수를 나타내며, K로 나누어 떨어지는 순열의 확률을 계산하는 데 필요합니다.

```cpp
int getMod(string &num){
    int res = 0;
    for(int i=0; i<num.length();i++){
        int digit = num[i] - '0';
        res = (res * 10 + digit) % K;
    }
    return res;
}
```
**설명 2**: 이 함수는 주어진 문자열 형식의 숫자를 K로 나눈 나머지를 계산합니다. 각 자리수의 값을 차례대로 처리하여 최종적으로 나머지를 반환합니다. 이는 동적 프로그래밍에서 숫자 조합의 나머지를 계산하는 데 사용됩니다.

```cpp
void solution(){
    for(int mask = 0; mask < (1<<N); mask++){
        for(int mod =0; mod < K; mod++){
            if(dp[mask][mod] == 0) continue;

            for(int i=0; i<N; i++){
                if(!(mask & (1 << i))){
                    int n_mask = mask | (1<<i);
                    int n_mod = (mod * ten_mod[nums[i].size()]%K + nums_mod[i]) % K; // (앞에 들어올 수의 나머지(10**nums[i]만큼 된거)  + 새로 들어온 숫자의 나머지) % K = 새로운 수의 나머지
                    dp[n_mask][n_mod] += dp[mask][mod];
                }
            }
        }
    }
```
**설명 3**: `solution()` 함수는 비트마스킹과 동적 프로그래밍을 사용하여 각 숫자의 조합을 생성하고, 해당 조합의 나머지를 계산하여 DP 테이블을 업데이트합니다. 최종 결과는 dp의 마지막 상태에서 K로 나누어 떨어지는 경우의 수를 찾습니다.

```cpp
void init(){
    cin >> N;
    denominator = factorial();
    for(int i=0; i<N; i++){
        cin >> nums[i];
    }
    cin >> K;
    dp[0][0] = 1;
    for(int i=0; i<N; i++){
        nums_mod[i] = getMod(nums[i]);
    }
    ten_mod[0] = 1%K;
    for(int i=1; i<=max_len; i++){
        ten_mod[i] = (ten_mod[i-1]*10)%K;
    }
}
```
**설명 4**: `init()` 함수는 입력을 읽고 초기화를 수행합니다. N과 K를 읽어오고, 각 숫자의 모듈 값을 계산하여 DP 배열을 초기화합니다. 또한, 10의 거듭제곱의 모듈 값을 계산하여 저장합니다.

### 시간/공간 복잡도 분석
- **시간 복잡도**: 이 알고리즘의 주요 루프는 (1<<N) * K * N입니다. 따라서, N이 최대 15인 경우 (1<<15) * 100 * 15 = 4915200으로 약 5백만의 계산을 하므로, O(N * K * 2^N)으로 나타낼 수 있습니다.
- **공간 복잡도**: DP 배열은 2^N * K 크기를 가지므로, O(2^N * K)입니다. N이 15일 때, DP 배열은 32768 * 101 = 3,305,728의 공간을 차지합니다.

### 코드 최적화 가능성 및 개선 제안
1. **메모리 최적화**: DP 배열이 2차원 배열을 사용하고 있어 메모리 사용량이 많습니다. 각 단계에서 필요하지 않은 이전 상태를 제거할 수 있는 방법을 사용하여 메모리를 절약할 수 있습니다. 현재 mask와 mod의 조합만 필요하기 때문에 1차원 배열로 최적화할 수 있습니다.
   
2. **팩토리얼 계산 최적화**: N이 최대 15로 작기 때문에 팩토리얼을 미리 계산해도 상관없지만, 매번 계산하는 대신 전역 변수로 캐싱하여 사용할 수 있습니다.

3. **가독성 향상**: 코드에 주석을 추가하여 각 부분의 의도를 명확히 하고, 함수명을 좀 더 직관적으로 바꿔 가독성을 높일 수 있습니다. 예를 들어, `getMod` 대신 `calculateModulo` 같은 이름을 사용할 수 있습니다.

4. **입력 처리 최적화**: `ios_base::sync_with_stdio(false);`와 `cin.tie(0);`를 사용하여 C++의 입출력 성능을 높인 것은 좋은 접근입니다. 그러나, `cout.tie(0);`는 필요하지 않을 수 있습니다. 

이러한 개선을 통해 코드의 성능과 유지보수성을 높일 수 있습니다.
</template>

