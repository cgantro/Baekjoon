# [Gold IV] 이진 검색 트리 - 5639 

[문제 링크](https://www.acmicpc.net/problem/5639) 

### 성능 요약

메모리: 2404 KB, 시간: 24 ms

### 분류

그래프 이론, 그래프 탐색, 트리, 재귀

### 제출 일자

2026년 2월 9일 13:45:18

### 문제 설명

<p>이진 검색 트리는 다음과 같은 세 가지 조건을 만족하는 이진 트리이다.</p>

<ul>
	<li>노드의 왼쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 작다.</li>
	<li>노드의 오른쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 크다.</li>
	<li>왼쪽, 오른쪽 서브트리도 이진 검색 트리이다.</li>
</ul>

<p style="text-align: center;"><img alt="" src="" style="height:242px; width:426px"></p>

<p>전위 순회 (루트-왼쪽-오른쪽)은 루트를 방문하고, 왼쪽 서브트리, 오른쪽 서브 트리를 순서대로 방문하면서 노드의 키를 출력한다. 후위 순회 (왼쪽-오른쪽-루트)는 왼쪽 서브트리, 오른쪽 서브트리, 루트 노드 순서대로 키를 출력한다. 예를 들어, 위의 이진 검색 트리의 전위 순회 결과는 50 30 24 5 28 45 98 52 60 이고, 후위 순회 결과는 5 28 24 45 30 60 52 98 50 이다.</p>

<p>이진 검색 트리를 전위 순회한 결과가 주어졌을 때, 이 트리를 후위 순회한 결과를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>트리를 전위 순회한 결과가 주어진다. 노드에 들어있는 키의 값은 10<sup>6</sup>보다 작은 양의 정수이다. 모든 값은 한 줄에 하나씩 주어지며, 노드의 수는 10,000개 이하이다. 같은 키를 가지는 노드는 없다.</p>

### 출력 

 <p>입력으로 주어진 이진 검색 트리를 후위 순회한 결과를 한 줄에 하나씩 출력한다.</p>

## AI 코드 리뷰

<template>

### 코드 리뷰
이 코드는 주어진 이진 검색 트리의 전위 순회 결과를 기반으로 후위 순회 결과를 출력하는 프로그램입니다. 프로그램은 다음과 같은 기능 단위로 나누어 설명할 수 있습니다:

```cpp
int pre_order[MAX];
```
- **설명 1**: 전역 배열 `pre_order`를 정의하여 입력으로 받은 전위 순회 결과를 저장합니다.

```cpp
void post_order(int start, int end){
    if(start > end) return;
    int root = pre_order[start];

    int mid = start + 1;

    // 서브트리 자르기
    while(mid <= end && pre_order[mid] < root){
        mid++;
    }

    post_order(start + 1, mid - 1);
    post_order(mid, end);
    cout << root << '\n';
}
```
- **설명 2**: `post_order` 함수는 재귀적으로 후위 순회를 수행합니다. 먼저 루트를 찾고, 왼쪽 서브트리와 오른쪽 서브트리의 경계를 찾은 후 각각에 대해 재귀 호출을 수행합니다. 마지막으로 루트 노드를 출력합니다.

```cpp
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int i = 0, n;
    memset(pre_order, 0, MAX);

    while(cin >> n){
        pre_order[i++] = n;
    }

    post_order(0, i - 1);
    return 0;
}
```
- **설명 3**: `main` 함수는 입력을 받고 `pre_order` 배열에 저장한 다음, `post_order` 함수를 호출하여 후위 순회를 시작합니다. 또한, 입출력 최적화를 위해 `ios::sync_with_stdio(false)`를 사용하여 C++의 입출력을 더 빠르게 처리합니다.

### 시간/공간 복잡도 분석
- **시간 복잡도**: 이 알고리즘은 각 노드에 대해 한 번씩 방문하므로 O(N)입니다. 여기서 N은 노드의 수입니다. 후위 순회를 위해 각 노드에 대해 서브트리를 찾는 과정도 포함되지만, 최악의 경우(일자로 쭉 펴진 트리)에도 O(N)의 시간 복잡도를 유지합니다.
- **공간 복잡도**: 전역 배열 `pre_order`에 O(N)의 공간을 사용하며, 재귀 호출 시 사용하는 스택 공간도 최악의 경우 O(N)까지 필요할 수 있습니다. 따라서 공간 복잡도는 O(N)입니다.

### 코드 최적화 가능성 및 개선 제안
- **코드 최적화 가능성**: 현재 코드에서 최적화할 부분은 거의 없지만, 입력을 받을 때 `memset(pre_order, 0, MAX);`를 사용하는 대신, `vector<int>`를 사용하여 동적으로 메모리를 할당하고, 초기화하는 것이 더 안전할 수 있습니다.
  
- **가독성 및 유지보수성**: 함수와 변수의 명명은 비교적 명확하지만, `mid`와 같은 변수 이름을 `right_subtree_start`와 같이 좀 더 설명적인 이름으로 변경하면 가독성이 향상될 수 있습니다. 또한, 코드에 주석을 추가하여 각 단계의 의도를 명확히 하면 유지보수성을 높일 수 있습니다.

- **입력 처리 개선**: 현재 입력 처리 방식은 EOF까지 읽는 것으로 되어 있는데, 만약 입력의 크기를 미리 알고 있다면 `for` 루프를 사용하는 것이 더욱 명확할 수 있습니다.

- **예외 처리**: 주어진 조건에 따라 유효한 입력이 들어올 것으로 가정하고 있지만, 예외 처리(예: 잘못된 입력에 대한 처리)를 추가하면 코드의 견고성을 높일 수 있습니다.

</template>

