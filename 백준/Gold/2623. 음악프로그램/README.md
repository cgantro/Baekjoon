# [Gold III] 음악프로그램 - 2623 

[문제 링크](https://www.acmicpc.net/problem/2623) 

### 성능 요약

메모리: 2176 KB, 시간: 0 ms

### 분류

그래프 이론, 방향 비순환 그래프, 위상 정렬

### 제출 일자

2026년 2월 19일 09:40:28

### 문제 설명

<p>인터넷 방송 KOI(Korea Open Internet)의 음악 프로그램 PD인 남일이는 자기가 맡은 프로그램 '뮤직 KOI'에서 가수의 출연 순서를 정하는 일을 매우 골치 아파한다. 순서를 정하기 위해서는 많은 조건을 따져야 한다.</p>

<p>그래서 오늘 출연 예정인 여섯 팀의 가수에 대해서 남일이가 보조 PD 세 명에게 각자 담당한 가수의 출연 순서를 정해오게 하였다. 보조 PD들이 가져온 것은 아래와 같다.</p>

<ul>
	<li>1 4 3</li>
	<li>6 2 5 4</li>
	<li>2 3</li>
</ul>

<p>첫 번째 보조 PD는 1번 가수가 먼저, 다음에 4번 가수, 다음에 3번 가수가 출연하기로 순서를 정했다. 두 번째 보조 PD는 6번, 2번, 5번, 4번 순으로 자기 담당 가수들의 순서를 정했다. 한 가수를 여러 보조 PD가 담당할 수도 있다. 마지막으로, 세 번째 보조 PD는 2번 먼저, 다음에 3번으로 정했다.</p>

<p>남일이가 할 일은 이 순서들을 모아서 전체 가수의 순서를 정하는 것이다. 남일이는 잠시 생각을 하더니 6 2 1 5 4 3으로 순서를 정했다. 이렇게 가수 순서를 정하면 세 보조 PD가 정해온 순서를 모두 만족한다. 물론, 1 6 2 5 4 3으로 전체 순서를 정해도 괜찮다.</p>

<p>경우에 따라서 남일이가 모두를 만족하는 순서를 정하는 것이 불가능할 수도 있다. 예를 들어, 세 번째 보조 PD가 순서를 2 3 대신에 3 2로 정해오면 남일이가 전체 순서를 정하는 것이 불가능하다. 이번에 남일이는 우리 나라의 월드컵 4강 진출 기념 음악제의 PD를 맡게 되었는데, 출연 가수가 아주 많다. 이제 여러분이 해야 할 일은 보조 PD들이 가져 온 순서들을 보고 남일이가 가수 출연 순서를 정할 수 있도록 도와 주는 일이다.</p>

<p>보조 PD들이 만든 순서들이 입력으로 주어질 때, 전체 가수의 순서를 정하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에는 가수의 수 N과 보조 PD의 수 M이 주어진다. 가수는 번호 1, 2,…,N 으로 표시한다. 둘째 줄부터 각 보조 PD가 정한 순서들이 한 줄에 하나씩 나온다. 각 줄의 맨 앞에는 보조 PD가 담당한 가수의 수가 나오고, 그 뒤로는 그 가수들의 순서가 나온다. N은 1이상 1,000이하의 정수이고, M은 1이상 100이하의 정수이다.</p>

### 출력 

 <p>출력은 N 개의 줄로 이뤄지며, 한 줄에 하나의 번호를 출력한 다. 이들은 남일이가 정한 가수들의 출연 순서를 나타낸다. 답이 여럿일 경우에는 아무거나 하나를 출력 한다. 만약 남일이가 순서를 정하는 것이 불가능할 경우에는 첫째 줄에 0을 출력한다.</p>

## AI 코드 리뷰

<template>

### 코드 리뷰
이 코드는 주어진 문제를 해결하기 위해 그래프 이론을 사용하여 가수의 출연 순서를 정하는 프로그램입니다. 프로그램은 보조 PD들이 제시한 가수의 출연 순서를 기반으로 방향 비순환 그래프(DAG)를 구성하고, 이를 통해 위상 정렬을 수행하여 유효한 출연 순서를 결정합니다.

```cpp
void init() {
    pds_pick.resize(M);
    adj.assign(N + 1, {});
    in_degree.assign(N + 1, 0);
    visited.assign(N + 1, 0);
    for (int i = 0; i < M; i++) {
        int k; cin >> k;
        pds_pick[i].resize(k);
        for (int j = 0; j < k; j++) {
            cin >> pds_pick[i][j];
        }
    }
```
- `init` 함수에서는 가수 수(N)와 PD 수(M)를 입력받고, 각 PD가 제안한 가수 순서를 `pds_pick`에 저장합니다. 그 후, 방향 그래프의 인접 리스트를 `adj`에 초기화하고, 각 노드의 진입 차수(`in_degree`)와 방문 여부(`visited`)를 초기화합니다.

```cpp
for (auto &pd : pds_pick) {
    for (int i = 0; i < (int)pd.size() - 1; i++) {
        int from = pd[i];
        int to = pd[i + 1];
        adj[from].push_back(to);
        in_degree[to]++;
    }
}
```
- PD들이 제안한 각 순서에 대해 인접 리스트를 구성하고, 각 가수의 진입 차수를 업데이트합니다. 이로써 그래프의 구조가 형성됩니다.

```cpp
bool checkCycle(const int& node) {
    visited[node] = 1;
    for (auto &nxt : adj[node]) {
        if (visited[nxt] == 0) {
            if (checkCycle(nxt)) return true;
        } else if (visited[nxt] == 1) {
            return true;
        }
    }
    visited[node] = 2;
    return false;
}
```
- `checkCycle` 함수는 DFS를 이용하여 그래프의 사이클을 탐지합니다. 사이클이 발견되면 `true`를 반환하고, 모든 노드가 방문되었으면 사이클이 없음을 나타냅니다.

```cpp
void Topology() {
    queue<int> q;
    vector<int> answer;
    for (int i = 1; i <= N; i++) {
        if (in_degree[i] == 0) q.push(i);
    }
    
    while (!q.empty()) {
        int node = q.front(); q.pop();
        answer.push_back(node);
        for (auto nxt : adj[node]) {
            in_degree[nxt]--;
            if (in_degree[nxt] == 0) q.push(nxt);
        }
    }

    for (int &node : answer) cout << node << '\n';
}
```
- `Topology` 함수는 위상 정렬을 수행합니다. 진입 차수가 0인 노드를 큐에 추가하고, 큐에서 하나씩 꺼내어 정렬된 순서에 추가합니다. 모든 가수가 출력되면 그 순서가 유효하다는 것을 의미합니다.

```cpp
void solution() {
    for (int i = 1; i <= N; i++) {
        if (visited[i]) continue;
        if (checkCycle(i)) {
            cout << 0 << '\n'; return;
        }
    }
    Topology();
}
```
- `solution` 함수는 그래프의 모든 노드에 대해 사이클 여부를 확인한 후, 사이클이 없다면 위상 정렬을 통해 출연 순서를 출력합니다. 사이클이 존재하면 `0`을 출력합니다.

### 시간/공간 복잡도 분석
- **시간 복잡도**: 
  - `init` 함수는 PD의 수(M)와 각 PD가 제안한 가수 수를 합산하여 O(M * K)의 시간 복잡도를 가집니다. (K는 평균적으로 각 PD가 제안한 가수 수)
  - `checkCycle` 함수는 DFS를 통해 모든 노드를 탐색하므로 O(N + E) (E는 간선 수)입니다.
  - `Topology` 함수도 모든 노드를 한 번씩 방문하므로 O(N + E)입니다.
  - 전체적으로 O(N + E + M * K)입니다.

- **공간 복잡도**: 
  - `pds_pick`, `adj`, `in_degree`, `visited`를 포함하여 O(N + M * K)입니다. 인접 리스트와 진입 차수 배열이 주요 공간 소모 요소입니다.

### 코드 최적화 가능성 및 개선 제안
- **최적화 가능성**: 
  - 현재 코드의 구조는 이미 효율적이며, 그래프를 탐색하는 DFS와 BFS 알고리즘을 활용하고 있으므로 크게 개선할 부분은 없습니다. 그러나 사이클 검출 및 위상 정렬을 결합하여 한 번의 DFS로 사이클 검출과 정렬을 동시에 수행하는 방법을 고려할 수 있습니다.

- **개선 제안**: 
  - 코드 가독성을 높이기 위해 주석을 추가하고, 함수와 변수의 이름을 보다 명확하게 변경하는 것이 좋습니다. 예를 들어, `checkCycle` 대신 `isCyclic`로 이름을 바꾸면 사이클 탐지 기능이 더 명확해질 수 있습니다.
  - `visited` 배열을 대신하여 노드의 상태를 나타내는 enum을 만들어 가독성을 높일 수 있습니다.
  - 입력 처리 및 결과 출력 부분에서 더욱 효율적인 방법(예: `vector::reserve`를 사용하여 벡터의 크기를 미리 할당하는 방법)으로 성능을 미세하게 개선할 수 있습니다.

- **유지보수성**: 
  - 코드의 구조가 명확하고 각 함수가 잘 나누어져 있어 유지보수성이 양호합니다. 하지만, 더 나은 가독성을 위해 각 함수의 역할을 주석으로 명확히 해주는 것이 좋습니다.

</template>

