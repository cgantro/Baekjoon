# [Gold II] 문제집 - 1766 

[문제 링크](https://www.acmicpc.net/problem/1766) 

### 성능 요약

메모리: 4216 KB, 시간: 24 ms

### 분류

그래프 이론, 자료 구조, 우선순위 큐, 방향 비순환 그래프, 위상 정렬

### 제출 일자

2026년 2월 19일 11:11:38

### 문제 설명

<p>민오는 1번부터 N번까지 총 N개의 문제로 되어 있는 문제집을 풀려고 한다. 문제는 난이도 순서로 출제되어 있다. 즉 1번 문제가 가장 쉬운 문제이고 N번 문제가 가장 어려운 문제가 된다.</p>

<p>어떤 문제부터 풀까 고민하면서 문제를 훑어보던 민오는, 몇몇 문제들 사이에는 '먼저 푸는 것이 좋은 문제'가 있다는 것을 알게 되었다. 예를 들어 1번 문제를 풀고 나면 4번 문제가 쉽게 풀린다거나 하는 식이다. 민오는 다음의 세 가지 조건에 따라 문제를 풀 순서를 정하기로 하였다.</p>

<ol>
	<li>N개의 문제는 모두 풀어야 한다.</li>
	<li>먼저 푸는 것이 좋은 문제가 있는 문제는, 먼저 푸는 것이 좋은 문제를 반드시 먼저 풀어야 한다.</li>
	<li>가능하면 쉬운 문제부터 풀어야 한다.</li>
</ol>

<p>예를 들어서 네 개의 문제가 있다고 하자. 4번 문제는 2번 문제보다 먼저 푸는 것이 좋고, 3번 문제는 1번 문제보다 먼저 푸는 것이 좋다고 하자. 만일 4-3-2-1의 순서로 문제를 풀게 되면 조건 1과 조건 2를 만족한다. 하지만 조건 3을 만족하지 않는다. 4보다 3을 충분히 먼저 풀 수 있기 때문이다. 따라서 조건 3을 만족하는 문제를 풀 순서는 3-1-4-2가 된다.</p>

<p>문제의 개수와 먼저 푸는 것이 좋은 문제에 대한 정보가 주어졌을 때, 주어진 조건을 만족하면서 민오가 풀 문제의 순서를 결정해 주는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 문제의 수 N(1 ≤ N ≤ 32,000)과 먼저 푸는 것이 좋은 문제에 대한 정보의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 둘째 줄부터 M개의 줄에 걸쳐 두 정수의 순서쌍 A,B가 빈칸을 사이에 두고 주어진다. 이는 A번 문제는 B번 문제보다 먼저 푸는 것이 좋다는 의미이다.</p>

<p>항상 문제를 모두 풀 수 있는 경우만 입력으로 주어진다.</p>

### 출력 

 <p>첫째 줄에 문제 번호를 나타내는 1 이상 N 이하의 정수들을 민오가 풀어야 하는 순서대로 빈칸을 사이에 두고 출력한다.</p>

## AI 코드 리뷰

<template>

### 코드 리뷰
이 코드는 주어진 문제를 해결하기 위해 위상 정렬(Topological Sort) 알고리즘을 사용하고 있습니다. 주어진 문제의 조건에 따라 문제를 풀 순서를 정하는 것이 목표입니다. 코드의 주요 기능은 다음과 같습니다.

```cpp
void init() {
    cin >> N >> M;
    adj.assign(N + 1, {});
    in_degree.assign(N + 1, 0);

    for (int i = 0; i < M; i++) {
        int from, to;
        cin >> from >> to;

        adj[from].push_back(to);
        in_degree[to]++;
    }
}
```
- **설명 1**: `init` 함수는 문제의 수 `N`과 우선 순위 정보의 수 `M`을 입력받고, 인접 리스트 `adj`와 각 노드의 진입 차수 `in_degree`를 초기화합니다. 각 문제 `from`과 `to` 간의 의존성을 입력받아 인접 리스트와 진입 차수를 업데이트합니다.

```cpp
void solution() {
    priority_queue<int, vector<int>, greater<int>> pq;
    vector<int> ans;
    for (int i = 1; i <= N; i++) {
        if (in_degree[i] == 0) pq.push(i);
    }

    while (!pq.empty()) {
        int node = pq.top(); pq.pop();
        ans.push_back(node);

        for (auto& nxt : adj[node]) {
            in_degree[nxt]--;
            if (in_degree[nxt] == 0) pq.push(nxt);
        }
    }

    for (int &node : ans) cout << node << " ";
}
```
- **설명 2**: `solution` 함수는 위상 정렬을 수행합니다. 진입 차수가 0인 노드를 우선 순위 큐에 추가하고, 큐에서 노드를 하나씩 꺼내어 결과 리스트 `ans`에 추가합니다. 꺼낸 노드와 연결된 노드의 진입 차수를 감소시키고, 만약 진입 차수가 0이 되면 해당 노드를 큐에 추가합니다. 마지막으로 결과를 출력합니다.

### 시간/공간 복잡도 분석
- **시간 복잡도**: O(N + M)
  - `N`은 문제의 수, `M`은 문제 간의 의존관계 수입니다. 각 문제와 의존관계를 한 번씩만 처리하기 때문에 총 시간 복잡도는 O(N + M)입니다.
  
- **공간 복잡도**: O(N + M)
  - 인접 리스트와 진입 차수를 저장하기 위해 N + M 만큼의 공간이 필요합니다.

### 코드 최적화 가능성 및 개선 제안
- **최적화 가능성**: 현재 코드의 시간 및 공간 복잡도는 최적 수준으로 보입니다. 주어진 문제의 제약 조건 내에서 더 이상의 최적화는 필요하지 않습니다.
  
- **개선 제안사항**:
  - `#include <bits/stdc++.h>` 대신 필요한 헤더 파일만 포함시켜 가독성을 높이고 컴파일 시간을 줄일 수 있습니다.
  - `using namespace std;`를 사용하지 않는 것이 좋습니다. 이는 네임스페이스 충돌을 방지하는데 유리합니다.
  - `cout` 출력 시 공백 처리를 위해 `std::ostream_iterator`를 사용할 수 있어 더욱 간결한 코드를 만들 수 있습니다.
  
- **코드 가독성 및 유지보수성**: 전반적으로 코드의 구조가 명확하며, 각 부분의 역할이 잘 나누어져 있어 가독성이 좋습니다. 그러나 주석을 추가하여 각 코드 블록의 의도를 명확히 하는 것이 좋습니다. 예를 들어, 진입 차수를 감소시키는 부분이나 우선 순위 큐의 사용 이유를 주석으로 설명하면 좋겠습니다.

</template>

